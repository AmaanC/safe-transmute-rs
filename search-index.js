var searchIndex = {};
searchIndex["safe_transmute"] = {"doc":"This crate contains checked implementations of `transmute()`.","items":[[3,"GuardError","safe_transmute","A slice boundary guard error, usually created by a `Guard`.",null,null],[12,"required","","The required amount of bytes for transmutation.",0,null],[12,"actual","","The actual amount of bytes.",0,null],[12,"reason","","Why this `required`/`actual`/`T` combo is an error.",0,null],[4,"Error","","A transmutation error. This type describes possible errors originating from operations in this crate.",null,null],[13,"Guard","","The data does not respect the target type's boundaries.",1,null],[13,"Unaligned","","The given data slice is not properly aligned for the target type. It would have been properly aligned if `offset` bytes were shifted (discarded) from the front of the slice.",1,null],[12,"offset","safe_transmute::Error","",1,null],[13,"InvalidValue","safe_transmute","The data contains an invalid value for the target type.",1,null],[4,"ErrorReason","","How the type's size compares to the received byte count and the transmutation function's characteristic.",null,null],[13,"NotEnoughBytes","","Too few bytes to fill even one instance of a type.",2,null],[13,"TooManyBytes","","Too many bytes to fill a type.",2,null],[13,"InexactByteCount","","The byte amount received is not the same as the type's size.",2,null],[5,"guarded_transmute_to_bytes_pod_many","","Transmute a slice of arbitrary types into a slice of their bytes.",null,null],[5,"guarded_transmute_to_bytes_many","","Transmute a slice of arbitrary types into a slice of their bytes.",null,null],[5,"guarded_transmute_to_bytes_pod","","Transmute a single instance of a POD type into a slice of its bytes.",null,null],[5,"guarded_transmute_to_bytes","","Transmute a single instance of an arbitrary type into a slice of its bytes.",null,null],[5,"guarded_transmute_pod_many_permissive","","View a byte slice as a slice of a POD type.",null,null],[5,"guarded_transmute_pod_vec_permissive","","Trasform a byte vector into a vector of POD.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"vec"}}],[5,"guarded_transmute_pod_many_pedantic","","View a byte slice as a slice of POD.",null,null],[5,"guarded_transmute_pod_vec_pedantic","","Trasform a byte vector into a vector of POD.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[5,"guarded_transmute_pod_pedantic","","Transmute a byte slice into a single instance of a POD.",null,null],[5,"guarded_transmute_pod_many","","Transmute a byte slice into a single instance of a POD.",null,null],[5,"guarded_transmute_pod_vec","","Trasform a byte vector into a vector of POD.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[5,"guarded_transmute_pod","","Transmute a byte slice into a single instance of a POD.",null,null],[5,"guarded_transmute_bool_vec_permissive","","Trasform a byte vector into a vector of bool.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[5,"guarded_transmute_bool_vec_pedantic","","Transform a byte vector into a vector of bool.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[5,"guarded_transmute_bool_permissive","","View a byte slice as a slice of boolean values.",null,null],[5,"guarded_transmute_bool_pedantic","","View a byte slice as a slice of boolean values.",null,null],[5,"guarded_transmute","","Transmute a byte slice into a single instance of a `Copy`able type.",null,null],[5,"guarded_transmute_pedantic","","Transmute a byte slice into a single instance of a `Copy`able type.",null,null],[5,"guarded_transmute_many","","View a byte slice as a slice of an arbitrary type.",null,null],[5,"guarded_transmute_many_permissive","","View a byte slice as a slice of an arbitrary type.",null,null],[5,"guarded_transmute_many_pedantic","","View a byte slice as a slice of an arbitrary type.",null,null],[5,"guarded_transmute_vec","","Trasform a byte vector into a vector of an arbitrary type.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[5,"guarded_transmute_vec_permissive","","Trasform a byte vector into a vector of an arbitrary type.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"vec"}}],[5,"guarded_transmute_vec_pedantic","","Trasform a byte vector into a vector of an arbitrary type.",null,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["vec","error"],"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"description","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"guarderror"}],"output":{"name":"error"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"guarderror"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"guarderror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"guarderror"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"errorreason"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"errorreason"}],"output":{"name":"bool"}}],[11,"hash","","",2,null],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"util","","Module containing various utility functions.",null,null],[5,"designalise_f32","safe_transmute::util","If the specified 32-bit float is a signaling NaN, make it a quiet NaN.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"designalise_f64","","If the specified 64-bit float is a signaling NaN, make it a quiet NaN.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[0,"guard","safe_transmute","The `guard` module exposes an API for memory boundary checking.",null,null],[3,"SingleValueGuard","safe_transmute::guard","Single value guard: The byte slice must have exactly enough bytes to fill a single instance of a type.",null,null],[3,"PedanticGuard","","Pedantic guard: The byte slice must have at least enough bytes to fill a single instance of a type, and should not have extraneous data.",null,null],[3,"AllOrNothingGuard","","An all-or-nothing guard: The byte slice should not have extraneous data, but can be empty, unlike `PedanticGuard`.",null,null],[3,"SingleManyGuard","","A single-or-many guard: The byte slice must have at least enough bytes to fill a single instance of a type, and extraneous data is ignored.",null,null],[3,"PermissiveGuard","","Permissive guard: The resulting slice would have as many instances of a type as will fit, rounded down. Therefore, this guard will never yield an error.",null,null],[8,"Guard","","The trait describes types which define boundary checking strategies. See the module-level documentation for more details.",null,null],[10,"check","","Check the size of the given byte slice against a particular type.",3,null],[11,"check","","",4,null],[11,"check","","",5,null],[11,"check","","",6,null],[11,"check","","",7,null],[11,"check","","",8,null],[8,"PodTransmutable","safe_transmute","Type that can be non-`unsafe`ly transmuted into",null,null]],"paths":[[3,"GuardError"],[4,"Error"],[4,"ErrorReason"],[8,"Guard"],[3,"SingleValueGuard"],[3,"PedanticGuard"],[3,"AllOrNothingGuard"],[3,"SingleManyGuard"],[3,"PermissiveGuard"]]};
initSearch(searchIndex);
